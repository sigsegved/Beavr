# Beavr - Implementation Details

**Version:** 3.0  
**Date:** January 19, 2026  
**Status:** Planning Phase

This document contains technical implementation details for the Beavr trading platform. For product overview and user-facing features, see [PRODUCT_SPEC.md](PRODUCT_SPEC.md).

---

## Table of Contents

1. [Strategy Engine Implementation](#1-strategy-engine-implementation)
2. [Data Models](#2-data-models)
3. [Database Schema](#3-database-schema)
4. [Plugin Architecture](#4-plugin-architecture)
5. [Broker Adapter Interface](#5-broker-adapter-interface)
6. [Project Structure](#6-project-structure)
7. [Dependencies](#7-dependencies)
8. [Module Responsibilities](#8-module-responsibilities)

---

## 1. Strategy Engine Implementation

### 1.1 BaseStrategy Interface

All strategies implement this interface:

```python
# beavr/strategies/base.py
from abc import ABC, abstractmethod
from pydantic import BaseModel, Field
from typing import ClassVar
from decimal import Decimal

class Signal(BaseModel):
    """Action signal generated by strategy evaluation"""
    symbol: str
    action: Literal["buy", "sell", "hold"]
    amount: Decimal | None = None      # Dollar amount (for buys)
    quantity: Decimal | None = None    # Shares (for sells)
    reason: str                         # Human-readable explanation
    confidence: float = 1.0            # 0.0 to 1.0

class StrategyContext(BaseModel):
    """Context provided to strategy during evaluation"""
    # Current state
    timestamp: datetime
    symbols: list[str]
    
    # Market data (per symbol)
    prices: dict[str, Decimal]              # Current prices
    bars: dict[str, pd.DataFrame]           # Historical OHLCV
    indicators: dict[str, dict[str, float]] # Computed indicators
    
    # Portfolio state (for this strategy only)
    cash_available: Decimal
    positions: dict[str, Position]          # Current holdings
    lots: list[Lot]                         # Lot-level detail
    budget_remaining: Decimal               # Budget left this period
    budget_spent_pct: float                 # % of budget deployed
    
    # Calendar
    days_to_month_end: int
    is_month_end_week: bool
    market_is_open: bool

class BaseStrategy(ABC, BaseModel):
    """
    Abstract base class for all trading strategies.
    
    Subclasses define configurable parameters as class attributes
    with Pydantic Field() for validation. The evaluate() method
    contains the trading logic.
    """
    
    # Metadata (override in subclass)
    name: ClassVar[str] = "Base Strategy"
    description: ClassVar[str] = ""
    version: ClassVar[str] = "1.0.0"
    
    # Schedule defaults (can be overridden in TOML)
    default_interval: ClassVar[str] = "1d"
    market_hours_only: ClassVar[bool] = True
    
    # Budget behavior
    budget_reset: ClassVar[str] = "never"  # "daily", "weekly", "monthly", "never"
    
    @abstractmethod
    def evaluate(self, ctx: StrategyContext) -> list[Signal]:
        """
        Evaluate market conditions and return trading signals.
        
        Args:
            ctx: Current market data, portfolio state, and calendar info
            
        Returns:
            List of Signal objects (can be empty for no action)
        """
        pass
    
    def required_indicators(self) -> dict[str, dict]:
        """
        Declare which indicators this strategy needs.
        Override to request specific indicators.
        
        Returns:
            Dict of indicator_name -> config
            Example: {"sma_20": {"type": "sma", "period": 20}}
        """
        return {}
    
    def on_fill(self, fill: OrderFill) -> None:
        """
        Called when an order generated by this strategy is filled.
        Override for custom fill handling (e.g., update internal state).
        """
        pass
    
    def on_start(self) -> None:
        """Called when strategy is started. Override for initialization."""
        pass
    
    def on_stop(self) -> None:
        """Called when strategy is stopped. Override for cleanup."""
        pass
```

### 1.2 Strategy Registry

Strategies are registered and discovered via decorators:

```python
# beavr/strategies/registry.py
from typing import Type

_STRATEGY_REGISTRY: dict[str, Type[BaseStrategy]] = {}

def register_strategy(name: str):
    """Decorator to register a strategy class"""
    def decorator(cls: Type[BaseStrategy]):
        _STRATEGY_REGISTRY[name] = cls
        return cls
    return decorator

def get_strategy(name: str) -> Type[BaseStrategy]:
    """Get a strategy class by name"""
    if name not in _STRATEGY_REGISTRY:
        raise ValueError(f"Unknown strategy: {name}. Available: {list(_STRATEGY_REGISTRY.keys())}")
    return _STRATEGY_REGISTRY[name]

def list_strategies() -> list[str]:
    """List all registered strategy names"""
    return list(_STRATEGY_REGISTRY.keys())
```

### 1.3 DCA Dip Strategy Implementation

```python
# beavr/strategies/dca_dip.py
"""
DCA with Dip Buying Strategy

Deploys budget on dips (price drops), with a fallback to deploy any
remaining budget near month-end. Designed for long-term accumulation
of broad ETFs like SPY, VOO, QQQ.
"""
from beavr.strategies.base import BaseStrategy, StrategyContext, Signal
from beavr.strategies.registry import register_strategy
from pydantic import Field
from decimal import Decimal
from typing import ClassVar

@register_strategy("dca_dip")
class DCADipStrategy(BaseStrategy):
    """Dollar-cost average into ETFs, buying dips with month-end fallback."""
    
    # Metadata
    name: ClassVar[str] = "DCA Dip"
    description: ClassVar[str] = "Buy dips with month-end fallback"
    version: ClassVar[str] = "1.0.0"
    budget_reset: ClassVar[str] = "monthly"
    default_interval: ClassVar[str] = "1d"
    
    # === Configurable Parameters (set via TOML) ===
    
    symbols: list[str] = Field(
        default=["SPY"],
        description="Symbols to accumulate"
    )
    weights: dict[str, float] = Field(
        default={},
        description="Allocation weights per symbol (equal if empty)"
    )
    dip_threshold: float = Field(
        default=0.02,
        ge=0.01,
        le=0.10,
        description="Buy when daily drop exceeds this (0.02 = 2%)"
    )
    dip_buy_pct: float = Field(
        default=0.50,
        ge=0.1,
        le=1.0,
        description="Fraction of remaining budget to deploy on dip"
    )
    fallback_days: int = Field(
        default=3,
        ge=1,
        le=5,
        description="Days before month-end to trigger fallback buy"
    )
    min_buy_amount: Decimal = Field(
        default=Decimal("25"),
        description="Minimum order size in dollars"
    )
    
    def required_indicators(self) -> dict[str, dict]:
        return {
            "daily_change": {"type": "daily_change"}
        }
    
    def evaluate(self, ctx: StrategyContext) -> list[Signal]:
        signals = []
        
        # Skip if no budget remaining
        if ctx.budget_remaining < self.min_buy_amount:
            return []
        
        # Calculate weights (equal if not specified)
        weights = self.weights or {s: 1.0 / len(self.symbols) for s in self.symbols}
        
        for symbol in self.symbols:
            daily_change = ctx.indicators[symbol].get("daily_change", 0)
            weight = weights.get(symbol, 1.0 / len(self.symbols))
            
            # Condition 1: Dip detected
            if daily_change <= -self.dip_threshold:
                amount = ctx.budget_remaining * Decimal(str(self.dip_buy_pct * weight))
                if amount >= self.min_buy_amount:
                    signals.append(Signal(
                        symbol=symbol,
                        action="buy",
                        amount=amount,
                        reason=f"Dip detected: {daily_change:.1%} drop"
                    ))
            
            # Condition 2: Month-end fallback (deploy remaining)
            elif ctx.days_to_month_end <= self.fallback_days:
                amount = ctx.budget_remaining * Decimal(str(weight))
                if amount >= self.min_buy_amount:
                    signals.append(Signal(
                        symbol=symbol,
                        action="buy",
                        amount=amount,
                        reason=f"Month-end fallback ({ctx.days_to_month_end} days left)"
                    ))
        
        return signals
```

### 1.4 Volatility Swing Strategy Implementation

```python
# beavr/strategies/volatility_swing.py
"""
Volatility Swing Trading Strategy

Buy volatile stocks on short-term dips, sell on bounces.
Uses percentage-based entry/exit relative to recent highs.
"""
from beavr.strategies.base import BaseStrategy, StrategyContext, Signal
from beavr.strategies.registry import register_strategy
from pydantic import Field
from decimal import Decimal
from typing import ClassVar

@register_strategy("volatility_swing")
class VolatilitySwingStrategy(BaseStrategy):
    """Buy dips, sell bounces on volatile stocks."""
    
    # Metadata
    name: ClassVar[str] = "Volatility Swing"
    description: ClassVar[str] = "Buy dips, sell bounces"
    version: ClassVar[str] = "1.0.0"
    budget_reset: ClassVar[str] = "never"  # Reuse capital
    default_interval: ClassVar[str] = "5m"  # Check frequently
    
    # === Configurable Parameters ===
    
    symbols: list[str] = Field(
        default=["TSLA", "NVDA"],
        description="Volatile stocks to trade"
    )
    lookback_days: int = Field(
        default=5,
        ge=2,
        le=20,
        description="Days to look back for range high"
    )
    entry_drop_pct: float = Field(
        default=0.03,
        ge=0.01,
        le=0.10,
        description="Buy when price drops this much from range high"
    )
    take_profit_pct: float = Field(
        default=0.03,
        ge=0.01,
        le=0.20,
        description="Sell when profit reaches this level"
    )
    stop_loss_pct: float = Field(
        default=0.05,
        ge=0.02,
        le=0.15,
        description="Sell when loss reaches this level"
    )
    max_hold_days: int = Field(
        default=10,
        ge=1,
        le=30,
        description="Force exit after this many days"
    )
    position_size: Decimal = Field(
        default=Decimal("500"),
        description="Dollar amount per position"
    )
    max_positions_per_symbol: int = Field(
        default=1,
        ge=1,
        le=5,
        description="Max concurrent positions per symbol"
    )
    
    def required_indicators(self) -> dict[str, dict]:
        return {
            f"range_high_{self.lookback_days}": {
                "type": "range_high", 
                "period": self.lookback_days
            }
        }
    
    def evaluate(self, ctx: StrategyContext) -> list[Signal]:
        signals = []
        indicator_key = f"range_high_{self.lookback_days}"
        
        for symbol in self.symbols:
            price = ctx.prices[symbol]
            range_high = ctx.indicators[symbol].get(indicator_key, price)
            position = ctx.positions.get(symbol)
            
            if position:
                # === EXIT LOGIC ===
                entry_price = position.avg_entry_price
                gain_pct = (price - entry_price) / entry_price
                hold_days = (ctx.timestamp - position.opened_at).days
                
                # Take profit
                if gain_pct >= self.take_profit_pct:
                    signals.append(Signal(
                        symbol=symbol,
                        action="sell",
                        quantity=position.quantity,
                        reason=f"Take profit: +{gain_pct:.1%}"
                    ))
                
                # Stop loss
                elif gain_pct <= -self.stop_loss_pct:
                    signals.append(Signal(
                        symbol=symbol,
                        action="sell",
                        quantity=position.quantity,
                        reason=f"Stop loss: {gain_pct:.1%}"
                    ))
                
                # Time-based exit
                elif hold_days >= self.max_hold_days:
                    signals.append(Signal(
                        symbol=symbol,
                        action="sell",
                        quantity=position.quantity,
                        reason=f"Time exit: held {hold_days} days"
                    ))
            
            else:
                # === ENTRY LOGIC ===
                # Check if price has dropped from recent high
                drop_pct = (range_high - price) / range_high
                
                if drop_pct >= self.entry_drop_pct:
                    if ctx.cash_available >= self.position_size:
                        signals.append(Signal(
                            symbol=symbol,
                            action="buy",
                            amount=self.position_size,
                            reason=f"Dip entry: {drop_pct:.1%} below {self.lookback_days}d high"
                        ))
        
        return signals
```

### 1.5 Custom Strategy Example

```python
# ~/.beavr/plugins/strategies/rsi_mean_reversion.py
"""
RSI Mean Reversion Strategy

Buy when RSI is oversold, sell when overbought.
Classic mean reversion approach.
"""
from beavr.strategies.base import BaseStrategy, StrategyContext, Signal
from beavr.strategies.registry import register_strategy
from pydantic import Field
from decimal import Decimal
from typing import ClassVar

@register_strategy("rsi_mean_reversion")
class RSIMeanReversionStrategy(BaseStrategy):
    """Mean reversion based on RSI oversold/overbought levels."""
    
    # Metadata
    name: ClassVar[str] = "RSI Mean Reversion"
    description: ClassVar[str] = "Buy oversold, sell overbought"
    version: ClassVar[str] = "1.0.0"
    default_interval: ClassVar[str] = "1h"
    
    # === Configurable Parameters ===
    symbols: list[str] = Field(default=["SPY"], description="Symbols to trade")
    rsi_period: int = Field(default=14, ge=5, le=30, description="RSI lookback period")
    oversold: float = Field(default=30, ge=10, le=40, description="RSI oversold threshold")
    overbought: float = Field(default=70, ge=60, le=90, description="RSI overbought threshold")
    position_size: Decimal = Field(default=Decimal("500"), description="$ per trade")
    
    def required_indicators(self) -> dict[str, dict]:
        return {
            f"rsi_{self.rsi_period}": {"type": "rsi", "period": self.rsi_period}
        }
    
    def evaluate(self, ctx: StrategyContext) -> list[Signal]:
        signals = []
        rsi_key = f"rsi_{self.rsi_period}"
        
        for symbol in self.symbols:
            rsi = ctx.indicators[symbol].get(rsi_key, 50)
            position = ctx.positions.get(symbol)
            
            if not position and rsi < self.oversold:
                signals.append(Signal(
                    symbol=symbol,
                    action="buy",
                    amount=self.position_size,
                    reason=f"Oversold: RSI={rsi:.1f} < {self.oversold}"
                ))
            
            elif position and rsi > self.overbought:
                signals.append(Signal(
                    symbol=symbol,
                    action="sell",
                    quantity=position.quantity,
                    reason=f"Overbought: RSI={rsi:.1f} > {self.overbought}"
                ))
        
        return signals
```

---

## 2. Data Models

### 2.1 Core Entities (Pydantic Models)

```python
from pydantic import BaseModel
from datetime import datetime
from typing import Literal
from decimal import Decimal

# Position - Aggregated holding for a symbol within a strategy
class Position(BaseModel):
    symbol: str                      # Stock symbol
    quantity: Decimal                # Total shares held
    avg_entry_price: Decimal         # Weighted average entry price
    market_value: Decimal            # Current market value
    unrealized_pl: Decimal           # Unrealized profit/loss
    opened_at: datetime              # When first lot was opened

# Lot - Individual purchase record for tracking
class Lot(BaseModel):
    id: str                          # Unique lot ID
    strategy_id: str                 # Which strategy owns this lot
    symbol: str                      # Stock symbol
    quantity: Decimal                # Number of shares
    entry_price: Decimal             # Price per share at entry
    entry_date: datetime             # When purchased
    alpaca_order_id: str             # Alpaca's order ID
    client_order_id: str             # Our tagged order ID
    status: Literal["open", "closed", "partial"]
    
# Virtual Account - Per-strategy allocation
class VirtualAccount(BaseModel):
    strategy_id: str                 # Strategy this account belongs to
    allocated_budget: Decimal        # Total allocated to strategy
    cash_available: Decimal          # Cash not in positions
    lots: list[Lot]                  # Open lots for this strategy

# Trade Record
class Trade(BaseModel):
    id: str
    symbol: str
    side: Literal["buy", "sell"]
    quantity: Decimal
    price: Decimal
    strategy_id: str
    lot_id: str                      # Links to lot
    alpaca_order_id: str
    executed_at: datetime
    
# Signal - Generated by strategy evaluation
class Signal(BaseModel):
    symbol: str
    action: Literal["buy", "sell", "hold"]
    amount: Decimal | None = None      # Dollar amount (for buys)
    quantity: Decimal | None = None    # Shares (for sells)
    reason: str                         # Human-readable explanation
    confidence: float = 1.0            # 0.0 to 1.0
```

### 2.2 Broker-Agnostic Models

```python
class BeavrOrder(BaseModel):
    """Broker-agnostic order representation"""
    id: str                              # Beavr's internal ID
    symbol: str
    side: Literal["buy", "sell"]
    qty: Optional[Decimal]               # Shares (mutually exclusive with notional)
    notional: Optional[Decimal]          # Dollar amount (for fractional)
    order_type: Literal["market", "limit", "stop", "stop_limit"]
    limit_price: Optional[Decimal]
    stop_price: Optional[Decimal]
    time_in_force: Literal["day", "gtc", "ioc", "fok"]
    extended_hours: bool = False
    
    # Beavr metadata (passed to broker if supported)
    strategy_id: str
    lot_id: str

class BeavrOrderResult(BaseModel):
    """Normalized order result from any broker"""
    beavr_order_id: str
    broker_order_id: str
    status: Literal["pending", "accepted", "filled", "partial", "cancelled", "rejected"]
    filled_qty: Decimal
    filled_avg_price: Optional[Decimal]
    filled_at: Optional[datetime]
    reject_reason: Optional[str]

class BeavrPosition(BaseModel):
    """Normalized position from any broker"""
    symbol: str
    qty: Decimal
    avg_entry_price: Decimal
    market_value: Decimal
    unrealized_pl: Decimal
    unrealized_pl_pct: Decimal

class BeavrQuote(BaseModel):
    """Normalized quote"""
    symbol: str
    bid: Decimal
    ask: Decimal
    last: Decimal
    timestamp: datetime

class OrderMapping(BaseModel):
    """Order ID mapping table (SQLite)"""
    beavr_order_id: str      # Our internal ID (UUID)
    broker_name: str         # "alpaca", "schwab", etc.
    broker_order_id: str     # Broker's order ID
    client_order_id: str     # Tag we sent (if supported)
    strategy_id: str
    lot_id: str
    created_at: datetime
```

---

## 3. Database Schema

### 3.1 SQLite Schema (Lot Ledger)

```sql
-- Lots table: tracks individual purchases per strategy
CREATE TABLE lots (
    id TEXT PRIMARY KEY,
    strategy_id TEXT NOT NULL,
    symbol TEXT NOT NULL,
    quantity REAL NOT NULL,
    entry_price REAL NOT NULL,
    entry_date TEXT NOT NULL,
    exit_price REAL,
    exit_date TEXT,
    alpaca_order_id TEXT NOT NULL,
    client_order_id TEXT NOT NULL,
    status TEXT DEFAULT 'open',
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- Trades table: all executed trades
CREATE TABLE trades (
    id TEXT PRIMARY KEY,
    symbol TEXT NOT NULL,
    side TEXT NOT NULL,
    quantity REAL NOT NULL,
    price REAL NOT NULL,
    strategy_id TEXT NOT NULL,
    lot_id TEXT,
    alpaca_order_id TEXT NOT NULL,
    executed_at TEXT NOT NULL,
    FOREIGN KEY (lot_id) REFERENCES lots(id)
);

-- Virtual accounts: per-strategy budgets
CREATE TABLE virtual_accounts (
    strategy_id TEXT PRIMARY KEY,
    allocated_budget REAL NOT NULL,
    cash_available REAL NOT NULL,
    updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- Reconciliation log: tracks sync with Alpaca
CREATE TABLE reconciliation_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    reconciled_at TEXT NOT NULL,
    alpaca_equity REAL,
    beavr_equity REAL,
    discrepancy REAL,
    status TEXT,
    notes TEXT
);

-- Order ID mapping (for multi-broker support)
CREATE TABLE order_mappings (
    beavr_order_id TEXT PRIMARY KEY,
    broker_name TEXT NOT NULL,
    broker_order_id TEXT NOT NULL,
    client_order_id TEXT,
    strategy_id TEXT NOT NULL,
    lot_id TEXT NOT NULL,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);
```

---

## 4. Plugin Architecture

Plugins let you add custom strategies and indicators **without modifying Beavr source code**.

### 4.1 Built-in vs Plugins

| Location | Contains | Who Maintains | Survives Upgrades |
|----------|----------|---------------|-------------------|
| `beavr/strategies/` | Built-in templates (`dca_dip`, `volatility_swing`) | Beavr project | N/A (part of package) |
| `beavr/indicators/builtins.py` | Built-in indicators (`sma`, `rsi`, etc.) | Beavr project | N/A (part of package) |
| `~/.beavr/plugins/strategies/` | Your custom strategies | You | ✅ Yes |
| `~/.beavr/plugins/indicators/` | Your custom indicators | You | ✅ Yes |

### 4.2 Why Use Plugins?

- **No fork required** - Keep your code separate from Beavr
- **Survives upgrades** - `pip install --upgrade beavr` won't overwrite your plugins
- **Private strategies** - Don't share proprietary trading logic
- **Easy sharing** - Give someone a `.py` file, they drop it in plugins folder

### 4.3 How Plugin Discovery Works

On startup, Beavr:
1. Loads built-in strategies/indicators from the package
2. Scans `~/.beavr/plugins/strategies/` for `.py` files
3. Scans `~/.beavr/plugins/indicators/` for `.py` files
4. Imports each file and registers classes with `@register_strategy` or `@register_indicator` decorators

```
~/.beavr/plugins/
├── strategies/
│   ├── pairs_trading.py     # @register_strategy("pairs_trading")
│   └── earnings_play.py     # @register_strategy("earnings_play")
└── indicators/
    ├── vwap.py              # @register_indicator("vwap")
    └── momentum_score.py    # @register_indicator("momentum_score")
```

### 4.4 Custom Indicator Example

```python
# ~/.beavr/plugins/indicators/vwap.py
"""
VWAP (Volume-Weighted Average Price) Indicator

Calculates the average price weighted by volume for intraday trading.
"""
from beavr.indicators.registry import register_indicator
from beavr.indicators.base import IndicatorResult
import pandas as pd

@register_indicator("vwap")
def compute_vwap(bars: pd.DataFrame, **params) -> IndicatorResult:
    """
    Args:
        bars: DataFrame with columns [open, high, low, close, volume]
        params: Additional parameters (unused for VWAP)
    
    Returns:
        IndicatorResult with computed values
    """
    typical_price = (bars['high'] + bars['low'] + bars['close']) / 3
    vwap = (typical_price * bars['volume']).cumsum() / bars['volume'].cumsum()
    
    return IndicatorResult(
        name="vwap",
        values=vwap,
        description="Volume-Weighted Average Price"
    )
```

### 4.5 Built-in Indicators

Computed locally using pandas-ta (Alpaca provides only raw OHLCV):

| Type | Description | Params |
|------|-------------|--------|
| `sma` | Simple Moving Average | `period` |
| `ema` | Exponential Moving Average | `period` |
| `rsi` | Relative Strength Index | `period` |
| `macd` | MACD histogram | `fast`, `slow`, `signal` |
| `bollinger` | Bollinger Bands | `period`, `std` |
| `atr` | Average True Range | `period` |
| `daily_change` | % change from previous close | - |
| `range_high` | Highest price in lookback | `period` |
| `range_low` | Lowest price in lookback | `period` |

---

## 5. Broker Adapter Interface

### 5.1 Broker Capabilities

```python
from enum import Flag, auto

class BrokerCapability(Flag):
    """Feature flags for broker capabilities"""
    FRACTIONAL_SHARES = auto()
    EXTENDED_HOURS = auto()
    CRYPTO = auto()
    OPTIONS = auto()
    PAPER_TRADING = auto()
    WEBSOCKET_STREAMING = auto()
    ORDER_TAGGING = auto()      # Can we tag orders with metadata?
    BRACKET_ORDERS = auto()
```

### 5.2 Abstract Broker Adapter

```python
from abc import ABC, abstractmethod

class BrokerAdapter(ABC):
    """
    Abstract base class for all broker integrations.
    
    Each broker adapter normalizes broker-specific responses
    to Beavr's internal models (BeavrOrder, BeavrPosition, etc.)
    """
    
    # Broker identification
    name: str                           # "alpaca", "schwab", "ibkr"
    display_name: str                   # "Alpaca", "Charles Schwab"
    capabilities: BrokerCapability      # Feature flags
    
    # Rate limiting
    max_requests_per_minute: int
    max_orders_per_day: Optional[int]
    
    @abstractmethod
    async def authenticate(self) -> bool:
        """Establish connection and verify credentials"""
        pass
    
    @abstractmethod
    async def get_account(self) -> BeavrAccount:
        """Get account info (cash, equity, buying power)"""
        pass
    
    @abstractmethod
    async def get_positions(self) -> list[BeavrPosition]:
        """Get all open positions, normalized to Beavr format"""
        pass
    
    @abstractmethod
    async def submit_order(self, order: BeavrOrder) -> BeavrOrderResult:
        """
        Submit an order to the broker.
        
        The adapter is responsible for:
        1. Translating BeavrOrder to broker's format
        2. Injecting order tag (if supported) for lot tracking
        3. Handling broker-specific validation
        4. Returning normalized BeavrOrderResult
        """
        pass
    
    @abstractmethod
    async def cancel_order(self, order_id: str) -> bool:
        """Cancel an open order"""
        pass
    
    @abstractmethod
    async def get_order(self, order_id: str) -> BeavrOrderResult:
        """Get order status by Beavr's internal order ID"""
        pass
    
    @abstractmethod
    async def get_bars(
        self, 
        symbol: str, 
        timeframe: str,
        start: datetime,
        end: datetime
    ) -> pd.DataFrame:
        """Get OHLCV bars for indicator computation"""
        pass
    
    @abstractmethod
    async def get_quote(self, symbol: str) -> BeavrQuote:
        """Get current quote (bid/ask/last)"""
        pass
    
    # Optional: Override if broker supports it
    async def get_order_by_client_id(self, client_order_id: str) -> Optional[BeavrOrderResult]:
        """Get order by our tagged client_order_id (if supported)"""
        return None  # Default: not supported
    
    def supports(self, capability: BrokerCapability) -> bool:
        """Check if broker supports a capability"""
        return capability in self.capabilities
```

### 5.3 Broker Factory

```python
from beavr.brokers import AlpacaAdapter, SchwabAdapter, IBKRAdapter

class BrokerFactory:
    """Factory to instantiate the correct broker adapter"""
    
    _adapters = {
        "alpaca": AlpacaAdapter,
        "schwab": SchwabAdapter,
        "ibkr": IBKRAdapter,
    }
    
    @classmethod
    def create(cls, broker_name: str, config: dict) -> BrokerAdapter:
        if broker_name not in cls._adapters:
            raise ValueError(f"Unknown broker: {broker_name}")
        
        adapter_class = cls._adapters[broker_name]
        return adapter_class(config)
    
    @classmethod
    def register(cls, name: str, adapter_class: type[BrokerAdapter]):
        """Register a custom broker adapter (plugin)"""
        cls._adapters[name] = adapter_class
```

### 5.4 Order Tagging Strategy

Since brokers have different order tagging capabilities:

**Order Tagging Format** (`client_order_id`):
```
bvr|<strategy_id>|<lot_id>|<timestamp>
Example: bvr|swing_trades|lot_001|1737312000
```

| Broker | Tagging Approach |
|--------|------------------|
| **Alpaca** | Full metadata in `client_order_id`: `bvr\|strategy\|lot\|ts` |
| **Schwab** | Use `client_order_id` but shorter, rely on local mapping |
| **IBKR** | Use `clientId` field, map internally |
| **No tagging** | Rely entirely on local order mapping table |

---

## 6. Project Structure

```
beavr/
├── src/
│   └── beavr/
│       ├── __init__.py
│       │
│       ├── models/                  # Shared domain models (Pydantic)
│       │   ├── __init__.py          # Re-exports all models
│       │   ├── order.py             # BeavrOrder, BeavrOrderResult
│       │   ├── position.py          # BeavrPosition, Lot
│       │   ├── trade.py             # Trade
│       │   ├── signal.py            # Signal
│       │   ├── account.py           # BeavrAccount, VirtualAccount
│       │   ├── quote.py             # BeavrQuote, Bar
│       │   └── config.py            # Config TOML schema models
│       │
│       ├── strategies/              # Strategy classes
│       │   ├── __init__.py          # Exports: BaseStrategy, get_strategy
│       │   ├── base.py              # BaseStrategy ABC, StrategyContext, Signal
│       │   ├── registry.py          # @register_strategy decorator
│       │   ├── dca_dip.py           # DCADipStrategy (built-in)
│       │   └── volatility_swing.py  # VolatilitySwingStrategy (built-in)
│       │
│       ├── indicators/              # Technical indicator computation
│       │   ├── __init__.py          # Exports: compute_indicators
│       │   ├── base.py              # Indicator interface
│       │   ├── registry.py          # @register_indicator decorator
│       │   └── builtins.py          # sma, ema, rsi, macd, atr, etc.
│       │
│       ├── core/                    # Core orchestration layer
│       │   ├── __init__.py          # Exports: Portfolio, Scheduler, Backtest
│       │   ├── portfolio.py         # Portfolio manager (virtual accounts)
│       │   ├── lots.py              # Lot ledger management
│       │   ├── executor.py          # Strategy execution: run strategies
│       │   ├── scheduler.py         # Scheduling: schedule(), run_daemon()
│       │   ├── config_loader.py     # Load and validate TOML configs
│       │   ├── reconciler.py        # Sync Beavr state with broker
│       │   └── backtest.py          # Backtesting engine
│       │
│       ├── brokers/                 # Broker adapters
│       │   ├── __init__.py          # Exports: BrokerFactory
│       │   ├── base.py              # BrokerAdapter ABC, BrokerCapability
│       │   └── alpaca/              # Alpaca implementation
│       │       ├── __init__.py
│       │       ├── adapter.py       # AlpacaAdapter
│       │       └── auth.py          # Alpaca auth helpers
│       │
│       ├── market_data/             # Market data providers
│       │   ├── __init__.py          # Exports: DataProviderFactory
│       │   ├── base.py              # DataProvider ABC
│       │   └── alpaca/              # Alpaca data implementation
│       │       ├── __init__.py
│       │       ├── provider.py      # AlpacaDataProvider
│       │       └── websocket.py     # Real-time streaming (future)
│       │
│       ├── db/                      # Database layer
│       │   ├── __init__.py
│       │   ├── connection.py        # SQLite connection manager
│       │   ├── migrations.py        # Schema migrations
│       │   └── queries.py           # Common queries
│       │
│       ├── notifications/           # Alert channels
│       │   ├── __init__.py
│       │   ├── base.py              # Notifier ABC
│       │   ├── discord.py           # Discord webhook
│       │   └── email.py             # Email notifications
│       │
│       └── cli/                     # CLI commands (Typer)
│           ├── __init__.py
│           ├── main.py              # Entry point: bvr
│           ├── strategy.py          # bvr strategy list|add|validate
│           ├── portfolio.py         # bvr portfolio|reconcile
│           ├── run.py               # bvr run|stop|status
│           ├── backtest.py          # bvr backtest
│           ├── trades.py            # bvr trades|lots
│           └── broker.py            # bvr broker auth|status
│
├── plugins/                         # User plugins (auto-discovered)
│   ├── strategies/                  # Custom strategy classes
│   └── indicators/                  # Custom indicators
│
├── tests/
│   ├── unit/
│   │   ├── test_strategies.py
│   │   ├── test_indicators.py
│   │   └── ...
│   └── integration/
│       ├── test_alpaca.py
│       └── ...
│
├── docs/
│   ├── PRODUCT_SPEC.md
│   └── IMPLEMENTATION.md
│
├── examples/
│   └── strategies/                  # Example strategy TOML configs
│       ├── my_etf_dca.toml
│       └── my_swing.toml
│
├── pyproject.toml
├── README.md
└── LICENSE
```

---

## 7. Dependencies

```toml
[tool.poetry.dependencies]
python = "^3.11"
alpaca-py = "^0.43"           # Broker integration (official SDK)
pandas = "^2.0"               # Data manipulation
pydantic = "^2.0"             # Data validation & models
typer = "^0.12"               # CLI framework
rich = "^13.0"                # CLI formatting & tables
toml = "^0.10"                # TOML configuration parsing
apscheduler = "^3.10"         # Scheduling
pandas-ta = "^0.3"            # Technical indicators (local computation)
httpx = "^0.27"               # HTTP client
python-dotenv = "^1.0"        # Environment variables

[tool.poetry.dev-dependencies]
pytest = "^8.0"
pytest-asyncio = "^0.23"
ruff = "^0.1"                 # Linting
mypy = "^1.8"                 # Type checking
```

---

## 8. Module Responsibilities

| Module | Responsibility | Key Exports |
|--------|----------------|-------------|
| **models/** | Shared Pydantic models | `BeavrOrder`, `BeavrPosition`, `Trade`, `Lot` |
| **strategies/** | Strategy base class and built-ins | `BaseStrategy`, `StrategyContext`, `Signal`, `@register_strategy` |
| **indicators/** | Technical indicator computation | `compute_indicators`, `@register_indicator` |
| **core/** | Portfolio management, execution, scheduling | `Portfolio`, `Executor`, `Scheduler`, `Backtest` |
| **brokers/** | Broker abstraction & implementations | `BrokerAdapter`, `AlpacaAdapter`, `BrokerFactory` |
| **market_data/** | Market data abstraction & implementations | `DataProvider`, `AlpacaDataProvider` |
| **db/** | SQLite persistence | `Database`, `LotRepository`, `TradeRepository` |
| **notifications/** | Alert delivery | `Notifier`, `DiscordNotifier`, `EmailNotifier` |
| **cli/** | Command-line interface | `app` (Typer) |

### 8.1 Data Flow

```
                    ┌─────────────┐
                    │   models/   │  ← Defines all shared types
                    └─────────────┘
                          ▲
          ┌───────────────┼───────────────┐
          │               │               │
    ┌─────┴─────┐   ┌─────┴─────┐   ┌─────┴─────┐
    │strategies/│   │   core/   │   │  brokers/ │
    │indicators/│   │           │   │           │
    └───────────┘   └───────────┘   └───────────┘
          │               │               │
          └───────────────┼───────────────┘
                          ▼
                    ┌─────────────┐
                    │    cli/     │
                    └─────────────┘
```

### 8.2 Design Rationale

| Decision | Reasoning |
|----------|-----------|
| **Python class strategies** | Type-safe, testable, debuggable, IDE support |
| **TOML for params** | Simple config, no gotchas, Python standard |
| **pandas-ta over TA-Lib** | Pure Python, no C dependencies, easier install |
| **SQLite** | Simple, file-based, no server needed, perfect for local state |
| **Typer + Rich** | Modern CLI, auto-completion, beautiful output |
| **Pydantic v2** | Fast validation, great DX, strategy param validation |
